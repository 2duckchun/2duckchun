# 버블정렬

가장 기본이 되는 정렬 알고리즘이다. for문을 2개 사용해서 구현할 수 있다.
구현방식에는 여러가지 방법이 있겠지만 대표적으로 **최솟값을 맨 앞으로 보내는 방식**과 **최댓값을 맨 뒤로 보내는 방식** 두 가지를 들 수 있겠다. 어떤 방식으로 구현하느냐에 따라 기준 단위가 되는 for문의 카운터 플래그가 달라진다. 

최솟값을 맨 앞으로 보내는 방식의 경우, 한번의 순회에서 반드시 최솟값이 앞으로 보내져야하므로 고정된 플래그가 필요하다.
예를 들어 i가 고정된 상태에서 j를 통해 모든 배열을 순회한다면 배열 중 가장 작은 값을 i 인덱스로 보낼 수 있다.
외부 for문의 플래그는 내부 for문이 전부 순회될 때까지 고정되므로 외부 for문을 플래그로 사용할 수 있다.

최댓값을 맨 뒤로 보내는 방식의 경우, 한번의 순회에서 반드시 최댓값이 배열의 끝으로 보내져야하므로 반복때마다 증감하는 플래그가 필요하다.
예를 들어 arr[0]에 최댓값이 존재할 때, arr[0], arr[1], arr[2] ... 순으로 밀고나가야 하기 때문이다.

이를 인지한다면 구현 자체는 어렵지 않다.

## 최적화

이미 정렬이 완성된 배열에는 더 이상 반복문이 수행될 필요가 없다. 즉 정렬 알고리즘에는 약간의 최적화를 곁들일 수 있다.

버블 정렬에서는 기준 단위가 최적화의 핵심 포인트인데, 최솟값을 맨 앞으로 보내는 방식이라면 매 순회마다 맨 앞의 요소가 최솟값인게 보장되므로 다음 순회에서는 고려할 필요가 없다.

마찬가지로 최댓값을 맨 뒤로 보내는 방식이라면 매 순회마다 맨 뒤의 요소가 최댓값인게 보장되므로 다음 순회에서는 고려할 필요가 없다.

따라서 기준 단위가 되는 카운터 플래그에서 반복횟수를 컨트롤 해줄 수 있다.

```c
#include <stdio.h>

int main() {
	// 최댓값을 밀어내는 방식
	int aList[5] = { 5, 4, 1, 3, 2 };
	for (int i = 0; i < 5; i++) {
		for (int j = 0; j < 4 - i; j++) {
			if (aList[j] > aList[j + 1]) {
				int temp = aList[j];
				aList[j] = aList[j + 1];
				aList[j + 1] = temp;
			}
		}
	}
	
	printf("최댓값을 밀어내는 방식으로 풀이\n");
	for (int i = 0; i < 5; i++) {
	printf("%d\t", aList[i]);
	}
	
	putchar("\n");

	// 최솟값을 앞에 두는 방식
	int lList[5] = { 5, 4, 1, 3, 2 };
	for (int i = 0; i < 5 - 1; i++) {
		for (int j = i + 1; j < 5; j++) {
			if (lList[i] > lList[j]) {
				int temp = lList[i];
				lList[i] = lList[j];
				lList[j] = temp;
			}
		}
	}

	printf("최솟값을 앞에 두는 방식으로 풀이\n");
	for (int i = 0; i < 5; i++) {
		printf("%d\t", lList[i]);
	}

	return 0;
}
```