## 추상 클래스

```ts
abstract class User {
    constructor(
        protected firstName: string,
        protected lastName: string,
        protected nickName: string,
    ){}

    abstract getNickName(): void
    abstract getFullName(): void
}

class Developer extends User {
    getNickName() {
        return `개발자 닉네임 ${this.nickName}`
    }
    getFullName() {
        return `개발자 풀네임 ${this.firstName} ${this.lastName}`
    }
    firstNameGetter = `이 사람은 ${this.firstName}씨입니다.`
}

class Designer extends User {
    getNickName() {
        return `디자이너 닉네임 ${this.nickName}`
    }
    getFullName() {
        return `디자이너 풀네임 ${this.firstName} ${this.lastName}`
    }
    lastNameGetter = `이 사람의 이름은 ${this.lastName}입니다.`
}

const KTS = new Developer('김', '태수', '2DC')
const Someone = new Designer('박', '디쟈이너', 'Designer')
```

### 추상 클래스(abstract class)
- 다른 클래스에 상속하기 위한 목적으로 설계된 클래스.
- 추상 클래스로는 직접적으로 인스턴스를 찍어낼 수 없다.

### 추상 메서드(abstract method)
- 추상 클래스 내에서 콜 시그니쳐만 명시한 메서드
- 추상 클래스를 상속받은 클래스에서 자유롭게 메서드를 만들어낼 수 있으나, 추상 메서드를 반드시 구현해야 한다.
- 추상 메서드의 콜 시그니처만 따르는 것 외의 제약은 없으므로, 하나의 추상 클래스에서 파생한 다양한 메서드를 만들어낼 수 있다.

### private, protected, public
- private : 클래스 내에서만 접근 가능한 프로퍼티를 만드는 보안 레벨.
- protected : 클래스를 상속받은 클래스에서도 프로퍼티에 접근할 수 있는 보안 레벨.
- public : 인스턴스에서도 자유롭게 프로퍼티에 접근할 수 있는 보안 레벨.

---

## 타입스크립트 클래스로 사전 만들기

```ts
type Words = {
    [key: string]: string
}

class Dict {
    private words: Words
    constructor() {
        this.words = {}
    }
    add(word: Word) {
        let term = word.term
        if (this.words[term] === undefined) {
            this.words[term] = word.def
        }
    }
    delete(word: Word) {
        let term = word.term
        if (this.words.hasOwnProperty(term)) {
            delete this.words[term]
        }
    }
    show() {
        console.log(this.words)
    }
}

class Word {
    constructor(
        public term: string,
        public def: string
    ){}
}

const dict = new Dict()
const kimchi = new Word('kimchi', '한국의 음식')
const bibimbap = new Word('bibimbap', '한국의 소울푸드')

dict.add(kimchi)
dict.add(bibimbap)
dict.delete(kimchi)
dict.show()
```

- 클래스 자체를 타입으로 사용하는 것은 그 클래스로 만든 인스턴스의 타입을 의미한다.
- constructor로 만들 프로퍼티가 아닌 경우, constructor 외부에 private, protected, public 등의 프로퍼티를 설정하고, constructor 내부에서 그 프로퍼티의 초기값을 설정해줄 수 있다.

---

## Type, Interface

```ts
// type
type SetA = {
    setA: string
}

type SetB = {
    setB: string
}

type AtoB = SetA & SetB

type BtoC = SetB & {
    setC: string
}

const AtoB: AtoB = {
    setA: "str",
    setB: "str"
}

const BtoC:BtoC = {
    setB: 'b',
    setC: 'c'
}

// interface
interface ClassA {
    A: string
}

interface ClassAB extends ClassA {
    B: string
}

interface Inherite {
    One: string
}

interface Inherite {
    Two: string
}

interface Inherite {
    Three: string
}

const classAB: ClassAB = {
    A: 'A',
    B: 'B'
}

const inherite:Inherite = {
    One: '1',
    Two: '2',
    Three: '3'
}
```

- type을 사용하면 여러 자료형을 표현할 수 있다.
- interface는 객체 지향을 표방한 방법으로써 객체의 형태만을 표현할 수 있다.
- type은 집합 개념으로 타입을 확장시킬 수 있고, interface는 상속 개념으로 타입을 확장시킬 수 있다.

---

## 추상 클래스와 인터페이스

### 추상 클래스

```ts
abstract class User {
    constructor(
        protected firstName: string,
        protected lastName: string
    ){}
    abstract sayHi(name:string): string
    abstract fullName(): string
}

class Player extends User {

    sayHi(name:string) {
        return `안녕 ${this.lastName}`
    }
    fullName() {
        return `${this.firstName} ${this.lastName}`
    }
}
```

JS로 트랜스파일 이후

```js
class User {
    constructor(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
}
class Player extends User {
    sayHi(name) {
        return `안녕 ${this.lastName}`;
    }
    fullName() {
        return `${this.firstName} ${this.lastName}`;
    }
}
```

- 추상클래스가 TS에서만 기능하더라도, 클래스의 종류 중 하나이므로 JS로 컴파일된 이후에도 class로 남아있게 된다.
- 추상클래스를 구현할 클래스는 extends를 이용해 클래스를 확장한다.

### 인터페이스

```ts
interface User {
    firstName: string,
    lastName: string,
    health: number
}

interface UserAction {
    sayHi(name:string): string
    fullName(): string
}

class Player implements User, UserAction {
    constructor(
        public firstName: string,
        public lastName: string,
        public health: number
    ){}

    fullName() {
        return `${this.firstName} ${this.lastName}`
    }

    sayHi(name: string) {
        return `안녕 ${this.lastName}`
    }
}

const makeUser = (userInfo: User): Player => {
    return new Player(userInfo.firstName, userInfo.lastName, userInfo.health)
}

const 덕춘 = makeUser({
    firstName: '김',
    lastName: '태수',
    health: 299792458
})
```

- 트랜스파일링 이후

```js
class Player {
    constructor(firstName, lastName, health) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.health = health;
    }
    fullName() {
        return `${this.firstName} ${this.lastName}`;
    }
    sayHi(name) {
        return `안녕 ${this.lastName}`;
    }
}
const makeUser = (userInfo) => {
    return new Player(userInfo.firstName, userInfo.lastName, userInfo.health);
};
const 덕춘 = makeUser({
    firstName: '김',
    lastName: '태수',
    health: 299792458
});
```

- 인터페이스는 타입스크립트에만 존재하므로, JS로 트랜스파일링 된 이후에는 인터페이스가 모두 사라진다.
- 추상 클래스처럼 클래스를 확장하는 개념이 아니라, 인터페이스를 클래스로 구현한다는 개념이므로 extends 대신 implements 키워드를 이용한다.
- 인터페이스로 클래스를 구현할 시, constructor의 프로퍼티에는 public만 허용된다.
- 인터페이스는 곧 객체를 표현하는 장치이므로, 인터페이스를 이용해 객체의 타입을 명시해줄수도 있다.

## 인터페이스와 제네릭을 이용한 폴리모피즘 구현

```ts
interface Note<T> {
    [key:string]: T
}

class FillNote<T> {
    constructor(
    private note: Note<T> = {}    
    ){}

    set(key:string, value:T) {
        this.note[key] = value
    }

    get(key:string) {
        return this.note[key]
    }

    delete(key:string) {
        delete this.note[key]
    }

    show() {
        console.log(this.note)
    }
}

const fillNoteWithBoolean = new FillNote<boolean>()
fillNoteWithBoolean.set('참이슬', true)
fillNoteWithBoolean.set('처음처럼', false)
fillNoteWithBoolean.set('켈리', true)

const fillNoteWithString = new FillNote<string>()
fillNoteWithString.set('이덕', '춘')
fillNoteWithString.set('이', '덕춘')

const fillNoteWithAll = new FillNote()
fillNoteWithAll.set('불리언', true)
fillNoteWithAll.set('문자열', '문자열')
fillNoteWithAll.set('숫자', 123)
fillNoteWithAll.set('문자배열', ['ㄱ', 'ㄴ', 'ㄷ', 'ㄹ'])


fillNoteWithBoolean.delete('참이슬')
const isKellyTrue = fillNoteWithBoolean.get('켈리')
console.log('켈리는 진또배기인가', isKellyTrue)
fillNoteWithString.show()
fillNoteWithBoolean.show()
fillNoteWithAll.show()
```

- 제네릭은 플레이스홀더처럼 여겨야 한다.
- 클래스의 선언부에 제네릭이 있으므로, 클래스를 선언할때는 제네릭도 함깨 채워주어야 한다.
- 선언시 제네릭을 채워주지 않아도 상관은 없다. 다만 그럴 경우에는 클래스가 리턴하는 값의 타입이 unknown이 될 수 있다. (의도한 바이면 상관이 없겠지만)
