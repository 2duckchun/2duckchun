# 인라인 함수

## 함수 호출에 따른 오버헤드

- 함수는 효율적인 프로그래밍 기법이지만 호출할 시 대가가 따른다. 함수 호출과 실행을 마치고 돌아오는 과정에서 아래와 같은 자원 소모가 발생한다.

```
함수 호출 -> 돌아올 리턴 주소 저장 -> CPU 레지스터 값 저장 -> 함수 매개변수를 스택에 저장 -> 함수 실행 ->

함수의 리턴값을 임시 저장소에 저장 -> 저장한 레지스터값 CPU에 복귀 -> 돌아갈 주소를 알아내어 리턴 -> 함수 호출 완료
```

- 위의 오버헤드 시간은 때에 따라 무시할 수 없는 비중을 차지하는 경우가 생긴다.

```cpp
#include <iostream>
using namespace std;

int odd(int x) {
    return x % 2;
}

int main() {
    int sum = 0;

    for (int i = 1; i <= 10000; i++) {
        if (odd(i)) sum += 1;
    }

    cout << sum;
}
```

- odd 함수가 10000번 호출됨에 따라 짧은 코드임에도 불구하고 오버헤드가 10000개가 생긴다.
- 이런 경우, 짤븡ㄴ 코드로 이루어진 함수에 오버헤드를 줄일 수 있는 방법이 있다면 프로그램의 실행 속도를 개선할 수 있을 것이다.

## 인라인 함수(inline function)

- 인라인 함수는 짧은 코드로 구성된 함수에 대해 함수 호출 오버헤드로 인한 프로그램의 실행속도 저하를 막기 위해 도입된 기능이다.
- 함수 앞에 inline 키워드를 이용하여 다음과 같이 선언한다.

```cpp
inline int odd(int x) {
    return x % 2;
}
```

- 컴파일러는 인라인 함수를 호출하는 곳에 인라인 함수의 코드를 그대로 삽입하여 함수 호출이 일어나지 않게 한다.
- 이렇게 되면, 함수 호출은 오버헤드가 없어지기 때문에 실행속도가 빨라진다.

## 인라인 함수의 장점

### 장점
- 작은 함수를 인라인으로 선언하면 프로그램의 실행속도를 향상시킬 수 있다.

### 단점
- 인라인 함수를 호출하는 곳에 단순 코드를 삽입하는 기능을 하므로 프로그램의 크기가 늘어나는 단점이 있다.

## 인라인 함수 제약사항

- inline 선언은 컴파일러에게 주는 일종의 요청이므로 강제 명령 사항이 아니다.
- 컴파일러는 함수의 크기나 효율을 따져서 불필요한 경우에 inline 선언을 무시할 수 있다.
- 컴파일러에 따라 재귀함수, static, 반복문, switch, goto문 등을 가진 함수는 인라인 함수로 허용하지 않는다.