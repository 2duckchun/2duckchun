# 문자열 입출력

문자열은 말 그대로 문자 배열인데, 문자가 한 글자씩 표현하는 것이라면 문자열은 여러개의 문자를 배열로 묶어서 표현하는 것이다.
즉 문자열을 char로 다루려면 char로 이루어진 배열을 만들어야 한다.

모든 데이터가 메모리에 저장되듯이, 문자열도 메모리에 저장이 된다.
메모리에서 문자열을 읽어들일 때, null(00)을 만나기 전까지의 모든 문자열을 읽는다.
이것을 string zero라고 한다.

만약 char 배열을 이용해 문자열을 다룰 경우,
초기 배열의 엘리먼트를 0(null)으로 맞추는 것이 중요할 수 있다.
배열에 0이 있어야 문자열이 끝난 줄 알고 컴퓨터가 문자열을 정확하게 읽어올 수 있기 때문이다.

## 디버깅을 통한 메모리 확인

아래 코드를 통해 메모리단에서 문자열을 확인해보자.

```c
#include <stdio.h>

int main(void) {
	char szName[32] = { 0 }; /* 32개가 다 0으로 채워짐 */
	printf("이름을 입력하세요.: ");
	gets(szName); /* 매개변수는 char*로 되어있음. 즉 포인터를 사용함 */
	printf("당신의 이름은 ");
	puts(szName); /* puts는 출력하면 자동으로 개행됨 */
	puts("입니다.");
	return 0;
}
```

- `F9` - 포지션 브레이크 포인트 설정 (디버그 모드)
- `F10` - 디버그 모드에서 코드 한 줄 실행

### 메모리 확인


![image](https://github.com/2duckchun/2duckchun/assets/92588154/7c5cbf4f-06a5-4e8b-a233-873b7f7c000c)
노란색 화살표는 다음에 실행될 문이다.
아직 szName[32] 배열이 선언되지 않았으므로 가변 메모리가 할당 안되고 있다.


![image](https://github.com/2duckchun/2duckchun/assets/92588154/14d687a9-de5d-4f90-a7b4-9401898c85b6)
szName이 선언됨과 동시에 0으로 초기화되었다.
한개의 `char` 는 1byte로 구성되어 있으며, 64비트 운영체제의 메모리단에서는 1byte가 8개씩 묶여 64비트를 이룬다. 
00으로 구성된 4줄은 총 32byte이므로 우리가 선언한 szName[32]와 동일하다.


![image](https://github.com/2duckchun/2duckchun/assets/92588154/2b472628-9a16-435d-993e-79a898a93045)
gets는 보안이슈가 있는 문자열 입력 함수이다. 지금은 실습차원에서 사용하고 있다.
아무튼 gets 함수에 szName 포인터를 넘겨 해당 배열에다가 키보드 인풋을 이용해 데이터를 집어넣었다.
그 결과, **i love 2DC!!** 라는 문자열이 메모리에 저장된 것을 확인할 수 있다.


![image](https://github.com/2duckchun/2duckchun/assets/92588154/944027e5-8412-4fbf-977a-447754d0ac13)
main 함수가 0을 return하면서 프로그램이 종료된다
